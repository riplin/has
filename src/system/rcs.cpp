//Copyright 2025-Present riplin

#include <has/system/rcs.h>

namespace Has::System::Resources
{

namespace Dma
{

static Mask_t s_Channels = Mask::Channel0 |
                           Mask::Channel1 |
                           Mask::Channel2 |
                           Mask::Channel3 |
                           Mask::Channel5 |
                           Mask::Channel6 |
                           Mask::Channel7;

    bool IsAvailable(Mask_t mask)
    {
        return (mask & s_Channels) != 0;
    }

    Dma_t Allocate(Mask_t mask)
    {
        mask &= s_Channels;
        if (mask != 0)
        {
            Dma_t ret = 0;
            while ((mask & 0x01) == 0)
            {
                mask >>= 1;
                ++ret;
            }
            s_Channels &= ~(1 << ret);
            return ret;
        }
        return Invalid;
    }

    void Free(Dma_t channel)
    {
        s_Channels |= 1 << channel;
    }
}

namespace Interrupt
{

//TODO: check the BDA if any standard peripherals are disabled and add those interrupts to the list.
static Mask_t s_Interrupts = Mask::Interrupt5 |
                             Mask::Interrupt7 |
                             Mask::Interrupt9 |
                             Mask::Interrupt10 |
                             Mask::Interrupt11 |
                             Mask::Interrupt12 |
                             Mask::Interrupt15;

    bool IsAvailable(Mask_t mask)
    {
        return (mask & s_Interrupts) != 0;
    }

    Interrupt_t Allocate(Mask_t mask)
    {
        mask &= s_Interrupts;
        if (mask != 0)
        {
            Interrupt_t ret = 0;
            while ((mask & 0x01) == 0)
            {
                mask >>= 1;
                ++ret;
            }
            s_Interrupts &= ~(1 << ret);
            return ret;
        }
        return Invalid;
   }

    void Free(Interrupt_t channel)
    {
        s_Interrupts |= 1 << channel;
    }
}

namespace Io
{

static uint32_t s_Ports[128] =
{
    0xFFFFFFFF, // 0x0000-0x001F    - DMA 1
    0xFFFFFFFF, // 0x0020-0x003F    - PIC 1
    0xFFFFFFFF, // 0x0040-0x005F    - PIT
    0xFFFFFFFF, // 0x0060-0x007F    - Keyboard controller, CMOS/RTC
    0xFFFFFFFF, // 0x0080-0x009F    - DMA, PS/2 POS
    0x0000FFFF, // 0x00A0-0x00BF    - PIC 2, -
    0xFFFFFFFF, // 0x00C0-0x00DF    - DMA 2
    0xFFFFFFFF, // 0x00E0-0x00FF    - Micro Channel, Co-Processor
    0x0000FFFF, // 0x0100-0x011F    - PS/2 POS
    0xFFFF0000, // 0x0120-0x013F    - Adaptec SCSI
    0x00FFFFFF, // 0x0140-0x015F    - SCSI, RTC
    0xFFFF0000, // 0x0160-0x017F    - HDC 2
    0x00000000, // 0x0180-0x019F    -
    0x00000000, // 0x01A0-0x01BF    -
    0x00000000, // 0x01C0-0x01DF    -
    0xFFFF0000, // 0x01E0-0x01FF    - HDC 1, A20 Gate control
    0x00000000, // 0x0200-0x021F
    0x00000000, // 0x0220-0x023F
    0x00000000, // 0x0240-0x025F
    0xFF000000, // 0x0260-0x027F    - Printer / PnP
    0x00000000, // 0x0280-0x029F
    0x00000000, // 0x02A0-0x02BF
    0x00000000, // 0x02C0-0x02DF
    0xFF00FF00, // 0x02E0-0x02FF    - 8514/A, COM port
    0x00000000, // 0x0300-0x031F
    0x00000000, // 0x0320-0x033F
    0x00000000, // 0x0340-0x035F
    0x00000000, // 0x0360-0x037F
    0x00000000, // 0x0380-0x039F
    0x00000000, // 0x03A0-0x03BF
    0x00000000, // 0x03C0-0x03DF
    0x00000000, // 0x03E0-0x03FF
    0x00000000, // 0x0400-0x041F
    0x00000000, // 0x0420-0x043F
    0x00000000, // 0x0440-0x045F
    0x00000000, // 0x0460-0x047F
    0x00000000, // 0x0480-0x049F
    0x00000000, // 0x04A0-0x04BF
    0x00000000, // 0x04C0-0x04DF
    0x00000000, // 0x04E0-0x04FF
    0x00000000, // 0x0500-0x051F
    0x00000000, // 0x0520-0x053F
    0x00000000, // 0x0540-0x055F
    0x00000000, // 0x0560-0x057F
    0x00000000, // 0x0580-0x059F
    0x00000000, // 0x05A0-0x05BF
    0x00000000, // 0x05C0-0x05DF
    0x00000000, // 0x05E0-0x05FF
    0x00000000, // 0x0600-0x061F
    0x00000000, // 0x0620-0x063F
    0x00000000, // 0x0640-0x065F
    0x00000000, // 0x0660-0x067F
    0x00000000, // 0x0680-0x069F
    0x00000000, // 0x06A0-0x06BF
    0x00000000, // 0x06C0-0x06DF
    0x00000000, // 0x06E0-0x06FF
    0x00000000, // 0x0700-0x071F
    0x00000000, // 0x0720-0x073F
    0x00000000, // 0x0740-0x075F
    0x00000000, // 0x0760-0x077F
    0x00000000, // 0x0780-0x079F
    0x00000000, // 0x07A0-0x07BF
    0x00000000, // 0x07C0-0x07DF
    0x00000000, // 0x07E0-0x07FF
    0x00000000, // 0x0800-0x081F
    0x00000000, // 0x0820-0x083F
    0x00000000, // 0x0840-0x085F
    0x00000000, // 0x0860-0x087F
    0x00000000, // 0x0880-0x089F
    0x00000000, // 0x08A0-0x08BF
    0x00000000, // 0x08C0-0x08DF
    0x00000000, // 0x08E0-0x08FF
    0x00000000, // 0x0900-0x091F
    0x00000000, // 0x0920-0x093F
    0x00000000, // 0x0940-0x095F
    0x00000000, // 0x0960-0x097F
    0x00000000, // 0x0980-0x099F
    0x00000000, // 0x09A0-0x09BF
    0x00000000, // 0x09C0-0x09DF
    0x00000000, // 0x09E0-0x09FF
    0x00000000, // 0x0A00-0x0A1F
    0x00000000, // 0x0A20-0x0A3F
    0x00000000, // 0x0A40-0x0A5F
    0x00000000, // 0x0A60-0x0A7F
    0x00000000, // 0x0A80-0x0A9F
    0x00000000, // 0x0AA0-0x0ABF
    0x00000000, // 0x0AC0-0x0ADF
    0x00000000, // 0x0AE0-0x0AFF
    0x00000000, // 0x0B00-0x0B1F
    0x00000000, // 0x0B20-0x0B3F
    0x00000000, // 0x0B40-0x0B5F
    0x00000000, // 0x0B60-0x0B7F
    0x00000000, // 0x0B80-0x0B9F
    0x00000000, // 0x0BA0-0x0BBF
    0x00000000, // 0x0BC0-0x0BDF
    0x00000000, // 0x0BE0-0x0BFF
    0x00000000, // 0x0C00-0x0C1F
    0x00000000, // 0x0C20-0x0C3F
    0x00000000, // 0x0C40-0x0C5F
    0x00000000, // 0x0C60-0x0C7F
    0x00000000, // 0x0C80-0x0C9F
    0x00000000, // 0x0CA0-0x0CBF
    0x00000000, // 0x0CC0-0x0CDF
    0x00000000, // 0x0CE0-0x0CFF
    0x00000000, // 0x0D00-0x0D1F
    0x00000000, // 0x0D20-0x0D3F
    0x00000000, // 0x0D40-0x0D5F
    0x00000000, // 0x0D60-0x0D7F
    0x00000000, // 0x0D80-0x0D9F
    0x00000000, // 0x0DA0-0x0DBF
    0x00000000, // 0x0DC0-0x0DDF
    0x00000000, // 0x0DE0-0x0DFF
    0x00000000, // 0x0E00-0x0E1F
    0x00000000, // 0x0E20-0x0E3F
    0x00000000, // 0x0E40-0x0E5F
    0x00000000, // 0x0E60-0x0E7F
    0x00000000, // 0x0E80-0x0E9F
    0x00000000, // 0x0EA0-0x0EBF
    0x00000000, // 0x0EC0-0x0EDF
    0x00000000, // 0x0EE0-0x0EFF
    0x00000000, // 0x0F00-0x0F1F
    0x00000000, // 0x0F20-0x0F3F
    0x00000000, // 0x0F40-0x0F5F
    0x00000000, // 0x0F60-0x0F7F
    0x00000000, // 0x0F80-0x0F9F
    0x00000000, // 0x0FA0-0x0FBF
    0x00000000, // 0x0FC0-0x0FDF
    0x00000000  // 0x0FE0-0x0FFF
};

static bool CheckAvailable(Io_t address)
{
    return (s_Ports[address >> 5] & (uint32_t(1) << (address & 0x001F))) == 0;
}

static void Allocate(Io_t address)
{
    s_Ports[address >> 5] |= uint32_t(1) << (address & 0x001F);
}

bool IsAvailable(Io_t baseAddress, uint16_t range)
{
    for (uint16_t index = 0; index < range; ++index)
    {
        if (!CheckAvailable(baseAddress + index))
            return false;
    }
    return true;
}

bool Allocate(Io_t baseAddress, uint16_t range)
{
    if (!IsAvailable(baseAddress, range))
        return false;

    for (uint16_t index = 0; index < range; ++index)
    {
        Allocate(baseAddress + index);
    }

    return true;
}

static void Free(Io_t address)
{
    s_Ports[address >> 5] &= ~(uint32_t(1) << (address & 0x001F));
}

void Free(Io_t baseAddress, uint16_t range)
{
    for (uint16_t index = 0; index < range; ++index)
    {
        Free(baseAddress + index);
    }
}

}

}